/*
 * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.wso2.eventsimulator.core.simulator.csvFeedSimulation.core;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.log4j.Logger;
import org.wso2.carbon.stream.processor.core.StreamDefinitionRetriever;
import org.wso2.eventsimulator.core.simulator.bean.FileStore;
import org.wso2.siddhi.core.event.Event;
import org.wso2.eventsimulator.core.internal.EventSimulatorDataHolder;
import org.wso2.eventsimulator.core.simulator.EventSimulator;
import org.wso2.eventsimulator.core.simulator.bean.FeedSimulationStreamConfiguration;
import org.wso2.eventsimulator.core.simulator.csvFeedSimulation.CSVFileSimulationDto;
import org.wso2.eventsimulator.core.simulator.exception.EventSimulationException;
import org.wso2.eventsimulator.core.util.EventConverter;
import org.wso2.eventsimulator.core.util.EventSender;
import org.wso2.eventsimulator.core.util.QueuedEvent;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Paths;
import java.util.LinkedHashMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeMap;
import java.util.Map;

/**
 * This simulator simulates the execution plan by sending events. These events are generated by
 * inputs from CSV file.
 * <p>
 * This simulator class implements EventSimulator Interface
 */
public class CSVFeedEventSimulator implements EventSimulator {
    private static final Logger log = Logger.getLogger(CSVFeedEventSimulator.class);
    private final Object lock = new Object();
    private CSVFileSimulationDto streamConfiguration;
    private volatile boolean isPaused = false;
    private volatile boolean isStopped = false;

    /**
     * Initialize CSVFeedEventSimulator to start the simulation
     *
     * @param streamConfiguration
     */
    public CSVFeedEventSimulator(CSVFileSimulationDto streamConfiguration) {
        this.streamConfiguration = streamConfiguration;
    }

    @Override
    public void pause() {
        isPaused = true;
    }

    @Override
    public void resume() {
        isPaused = false;
        synchronized (lock) {
            lock.notifyAll();
        }
    }

    @Override
    public void stop() {
        isPaused = true;
        isStopped = true;
        synchronized (lock) {
            lock.notifyAll();
        }
    }


    @Override
    public FeedSimulationStreamConfiguration getStreamConfiguration() {
        return streamConfiguration;
    }

    /**
     * start simulation for given configuration
     */
    @Override
    public void run() {
        sendEvent( streamConfiguration);
    }

    /**
     * This method must be called within databaseFeedSimulation synchronized block to avoid multiple file simulators from running simultaneously.
     * Read the values from uploaded CSV file and convert those values into event and send those events to
     * input handler
     * <p>
     * <p>
     * To read the CSV file It uses CSV parser Library.
     * {@link <databaseFeedSimulation href="https://commons.apache.org/proper/commons-csv/apidocs/org/apache/commons/csv/CSVParser.html">CSVParser</databaseFeedSimulation>}
     * </p>
     * <p>
     * <p>
     * CSV file can be separated by one of these fallowing character , , ; , \t by default
     * It has capability to have user defined delimiter
     * Any field may be quoted (with double quotes)
     * Fields with embedded commas or delimiter characters must be double quoted.
     * </p>
     * <p>
     * Initialize CSVParser
     *
     * @param csvFileConfig    CSVFileSimulationDto
     */
    private void sendEvent( CSVFileSimulationDto csvFileConfig) {
        // return no of events read from CSV file during ever iteration
        long noOfEvents = 0;
        int delay = csvFileConfig.getDelay();

        // Reader for reading character streams from file
        Reader in = null;

        // CSVParser to read CSV Values
        CSVParser csvParser = null;
        if (delay <= 0) {
            log.warn("Events will be sent continuously since the delay between events are set to "
                    + delay + " milliseconds");
            delay = 0;
        }

        LinkedHashMap<String,StreamDefinitionRetriever.Type> streamDefinition =
                EventSimulatorDataHolder.getInstance().getStreamDefinitionService().streamDefinitionService(csvFileConfig.getStreamName());

        try {
            // Initialize Reader
            if (FileStore.getFileStore().checkExists(csvFileConfig.getFileName())) {
                in = new FileReader(String.valueOf(Paths.get(System.getProperty("java.io.tmpdir"), csvFileConfig.getFileDto().getFileInfo().getFileName())));

                // Initialize CSVParser with appropriate CSVFormat according to delimiter
                if (!csvFileConfig.getDelimiter().isEmpty()) {
                    switch (csvFileConfig.getDelimiter()) {
                        case ",":
                            csvParser = new CSVParser(in, CSVFormat.DEFAULT);
                            break;
                        case ";":
                            csvParser = new CSVParser(in, CSVFormat.EXCEL);
                            break;
                        case "\\t":
                            csvParser = new CSVParser(in, CSVFormat.TDF);
                            break;
                        default:
                            csvParser = new CSVParser(in, CSVFormat.newFormat(csvFileConfig.getDelimiter().charAt(0)));
                    }

                    int attributeSize = streamDefinition.size();
                    Long timestamp;

//            create a treemap to hold csv file data. the key would be the timestamp and value will be a list of events
                    TreeMap<Long, ArrayList<Event>> eventsMap = new TreeMap<>();

                    // Iterate through the CSV file line by line
                    for (CSVRecord record : csvParser) {
                        try {
                            if (!isPaused) {
                                if (record.size() != attributeSize) {
                                    log.warn("No of attribute is not equal to attribute size: " + attributeSize + " is needed" + "in Row no:" + noOfEvents + 1);
                                }
                                String[] attributes = new String[attributeSize];
                                noOfEvents = csvParser.getCurrentLineNumber();

                                for (int i = 0; i < record.size(); i++) {
                                    attributes[i] = record.get(i);
                                }

                                //convert Attribute values into event
                                Event event = EventConverter.eventConverter(streamDefinition, attributes);
                                System.out.println("Input Event (CSV feed)" + Arrays.deepToString(event.getData()));

                                //send the event to input handler
                                if (csvFileConfig.getTimestampAttribute().isEmpty()) {
                                    EventSender.getInstance().sendEvent(csvFileConfig.getExecutionPlanName(), csvFileConfig.getStreamName(), event);
                                    //delay between two events
                                    if (delay > 0) {
                                        Thread.sleep(delay);
                                    }
                                } else {
                           /*
                           'timestamp attribute' specified the column number to be considered as the timestamp.
                            deduct one to obtain position number
                            */
                                    timestamp = Long.valueOf(attributes[(Integer.valueOf(csvFileConfig.getTimestampAttribute())) - 1]);
                                    if (!eventsMap.containsKey(timestamp)) {
                                        eventsMap.put(timestamp, new ArrayList<>());
                                    }
                                    eventsMap.get(timestamp).add(event);
                                }
                            } else if (isStopped) {
                                break;
                            } else {
                                synchronized (lock) {
                                    try {
                                        lock.wait();
                                    } catch (InterruptedException e) {
                                        Thread.currentThread().interrupt();
                                        continue;
                                    }
                                }
                            }
                        } catch (EventSimulationException e) {
                            log.error("Event dropped due to Error occurred during generating an event : " + e.getMessage());
                        } catch (InterruptedException e) {
                            log.error("Error occurred during send event : " + e.getMessage());
                        }
                    }
//            if the csv feed simulation has orderByTimestamp attribute set to true and if eventsmap is not empty send the sorted csv events
                    if (!csvFileConfig.getTimestampAttribute().isEmpty() && !eventsMap.isEmpty()) {
                        for (Map.Entry<Long, ArrayList<Event>> events : eventsMap.entrySet()) {
                            for (Event event : events.getValue()) {
                                EventSender.getInstance().sendEvent(csvFileConfig.getExecutionPlanName(), csvFileConfig.getStreamName(),
                                        new QueuedEvent(events.getKey(), event));
                                System.out.println("sorted input event sent to event queue(csv feed) : " + events.getKey());
                                if (delay > 0) {
                                    Thread.sleep(delay);
                                }
                            }
                        }
                    }
                }
            } else {
                log.error("File '" + csvFileConfig.getFileName() +"' has not been uploaded." );
            }

        } catch (IllegalArgumentException e) {
            throw new EventSimulationException("File Parameters are null" + e.getMessage());
        } catch (FileNotFoundException e) {
            throw new EventSimulationException("File not found :" + csvFileConfig.getFileDto().getFileInfo().getFileName());
        } catch (IOException e) {
            throw new EventSimulationException("Error occurred while reading the file");
        } catch (InterruptedException e) {
            throw new EventSimulationException("Event simulation was interrupted : " + e.getMessage());
        }  finally {
            try {
                if (in != null) {
                    in.close();
                }
                if (csvParser != null) {
                    csvParser.close();
                }
            } catch (IOException e) {
                throw new EventSimulationException("Error occurred during closing the file");
            }
        }
    }
}

